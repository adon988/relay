<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>Thinking in GraphQL | Relay Docs</title><meta name="viewport" content="width=device-width"><meta property="og:title" content="Thinking in GraphQL | Relay Docs"><meta property="og:type" content="website"><meta property="og:url" content="http://facebook.github.io/relay/index.html"><meta property="og:description" content="A JavaScript framework for building data-driven React applications"><link rel="shortcut icon" href="/relay/img/favicon.png"><link rel="stylesheet" href="/relay/css/relay.css"><script type="text/javascript" src="//use.typekit.net/vqa1hcx.js"></script><script type="text/javascript">try{Typekit.load();}catch(e){}</script></head><body><div class="container"><div class="nav-main"><div class="wrap"><a class="nav-home" href="/relay/"><img class="nav-logo" src="/relay/img/logo.svg" width="50" height="50">Relay</a><ul class="nav-site"><li><a href="/relay/prototyping/playground.html" class="">Try it out</a></li><li><a href="/relay/docs/getting-started.html#content" class="active">Docs</a></li><li><a href="/relay/support.html" class="">Support</a></li><li><a href="https://github.com/facebook/relay" class="">GitHub</a></li></ul></div></div><section class="content wrap documentationContent"><div class="nav-docs"><div class="nav-docs-section"><h3>Quick Start</h3><ul><li><a style="margin-left:0;" class="" href="/relay/docs/getting-started.html#content">Getting Started</a></li><li><a style="margin-left:0;" class="" href="/relay/docs/tutorial.html#content">Tutorial</a></li><li><a style="margin-left:0;" class="active" href="/relay/docs/thinking-in-graphql.html#content">Thinking in GraphQL</a></li><li><a style="margin-left:0;" class="" href="/relay/docs/thinking-in-relay.html#content">Thinking In Relay</a></li><li><a style="margin-left:0;" class="" href="/relay/docs/videos.html#content">Videos</a></li></ul></div><div class="nav-docs-section"><h3>Guides</h3><ul><li><a style="margin-left:0;" class="" href="/relay/docs/guides-containers.html#content">Containers</a></li><li><a style="margin-left:0;" class="" href="/relay/docs/guides-routes.html#content">Routes</a></li><li><a style="margin-left:0;" class="" href="/relay/docs/guides-root-container.html#content">Root Container</a></li><li><a style="margin-left:0;" class="" href="/relay/docs/guides-ready-state.html#content">Ready State</a></li><li><a style="margin-left:0;" class="" href="/relay/docs/guides-mutations.html#content">Mutations</a></li><li><a style="margin-left:0;" class="" href="/relay/docs/guides-network-layer.html#content">Network Layer</a></li><li><a style="margin-left:0;" class="" href="/relay/docs/guides-babel-plugin.html#content">Babel Relay Plugin</a></li></ul></div><div class="nav-docs-section"><h3>GraphQL</h3><ul><li><a style="margin-left:0;" class="" href="/relay/docs/graphql-relay-specification.html#content">GraphQL Relay Specification</a></li><li><a style="margin-left:20px;" class="" href="/relay/docs/graphql-object-identification.html#content">Object Identification</a></li><li><a style="margin-left:20px;" class="" href="/relay/docs/graphql-connections.html#content">Connection</a></li><li><a style="margin-left:20px;" class="" href="/relay/docs/graphql-mutations.html#content">Mutations</a></li><li><a style="margin-left:20px;" class="" href="/relay/docs/graphql-further-reading.html#content">Further Reading</a></li></ul></div><div class="nav-docs-section"><h3>API Reference</h3><ul><li><a style="margin-left:0;" class="" href="/relay/docs/api-reference-relay.html#content">Relay</a></li><li><a style="margin-left:0;" class="" href="/relay/docs/api-reference-relay-container.html#content">RelayContainer</a></li><li><a style="margin-left:0;" class="" href="/relay/docs/api-reference-relay-route.html#content">Relay.Route</a></li><li><a style="margin-left:0;" class="" href="/relay/docs/api-reference-relay-root-container.html#content">Relay.RootContainer</a></li><li><a style="margin-left:0;" class="" href="/relay/docs/api-reference-relay-ql.html#content">Relay.QL</a></li><li><a style="margin-left:0;" class="" href="/relay/docs/api-reference-relay-mutation.html#content">Relay.Mutation</a></li><li><a style="margin-left:0;" class="" href="/relay/docs/api-reference-relay-proptypes.html#content">Relay.PropTypes</a></li><li><a style="margin-left:0;" class="" href="/relay/docs/api-reference-relay-store.html#content">Relay.Store</a></li></ul></div><div class="nav-docs-section"><h3>Interfaces</h3><ul><li><a style="margin-left:0;" class="" href="/relay/docs/interfaces-relay-network-layer.html#content">RelayNetworkLayer</a></li><li><a style="margin-left:20px;" class="" href="/relay/docs/interfaces-relay-mutation-request.html#content">RelayMutationRequest</a></li><li><a style="margin-left:20px;" class="" href="/relay/docs/interfaces-relay-query-request.html#content">RelayQueryRequest</a></li></ul></div></div><div class="inner-content"><a id="content"></a><a class="edit-page-link" href="https://github.com/facebook/relay/blob/master/docs/QuickStart-ThinkingInGraphQL.md" target="_blank">Edit on GitHub</a><h1>Thinking in GraphQL</h1><div><p>GraphQL 為客戶端提出了一個新的方式，藉由 聚焦在產品開發者們和客戶端應用程式的需求去抓取資料。它提供一個方式給開發者們針對 view 指定精準的資料需求，並讓客戶端在單一的網路請求去抓取那些資料。與傳統的方法像是 REST 做比較，GraphQL 幫助應用程式更有效率地抓取資料 (相對於資源導向的 REST 方法) 並避免伺服器邏輯的重複 (可能會在客製化的 endpoints 發生)。此外，GraphQL 幫助開發者們解開產品程式碼和伺服器的邏輯之間的耦合。例如，產品可以抓取更多或更少的資訊而不需改變每一個相關的伺服器 endpoint。這是一個抓取資料的好方式。</p><p>在這篇文章，我們將會探索建置一個 GraphQL 客戶端框架意味著什麼，還有這如何與使用比較傳統的 REST 系統的客戶端做比較。在這個過程中，我們將會關注 Relay 背後的設計決策並看到它不只是一個 GraphQL 客戶端也是一個 <em>declarative 資料抓取</em> 的框架。讓我們從頭開始並抓取一些資料！</p><h2><a class="anchor" name=""></a>抓取資料 <a class="hash-link" href="#">#</a></h2><p>想像我們有一個簡易的應用程式，它抓取一份 story 的清單，還有每個 story 的一些細節資訊。以下是它在資源導向 REST 中可能的樣貌：</p><pre class="prism language-javascript">
<span spellcheck="true" class="token comment">// 抓取 story IDs 的清單，但不包含它們的細節資訊：</span>
rest<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">&#x27;/stories&#x27;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>stories <span class="token operator">=</span><span class="token operator">&gt;</span>
  <span spellcheck="true" class="token comment">// 這 resolve 成有連結的資源項目清單：</span>
  <span spellcheck="true" class="token comment">// `[ { href: &quot;http://.../story/1&quot; }, ... ]`</span>
  Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span>stories<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>story <span class="token operator">=</span><span class="token operator">&gt;</span>
    rest<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span>story<span class="token punctuation">.</span>href<span class="token punctuation">)</span> <span spellcheck="true" class="token comment">// Follow the links</span>
  <span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>stories <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  <span spellcheck="true" class="token comment">// 這 resolve 成一個 story 項目的清單：</span>
  <span spellcheck="true" class="token comment">// `[ { id: &quot;...&quot;, text: &quot;...&quot; } ]`</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>stories<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre><p>要注意這個方法需要送 <em>n+1</em> 個請求到伺服器：1 個抓取清單，其他 <em>n</em> 抓取每一個項目。藉著 GraphQL 我們可以在一個到伺服器的單一網路請求抓取一樣的資料 (不需要建立一個客製化而且接著需要去維護的 endpoint)：</p><pre class="prism language-javascript">
graphql<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`query { stories { id, text } }`</span></span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>
  stories <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span spellcheck="true" class="token comment">// story 項目的清單：</span>
    <span spellcheck="true" class="token comment">// `[ { id: &quot;...&quot;, text: &quot;...&quot; } ]`</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>stories<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span></pre><p>到目前為止，我們只是使用 GraphQL 作為一個比典型 REST 方法更有效率的版本。請記住在 GraphQL 的版本中有兩個重要的好處：</p><ul><li>用一次往返抓取所有資料。</li><li>客戶端跟伺服器是解耦的：客戶端指定需要的資料而不是<em>依賴</em>伺服器 endpoint 回傳正確的資料。</li></ul><p>對簡易的應用程式來說，這已經是個好的改進。</p><h2><a class="anchor" name=""></a>客戶端快取 <a class="hash-link" href="#">#</a></h2><p>重複地從伺服器重新抓取資訊可能會非常的慢。例如，從 story 的清單，換頁到清單中的一個項目，再回到 story 的清單意味著我們必須重新抓取整個清單。我們解決這個問題，將會使用標準的解決方案：<em>快取</em>。</p><p>在一個資源導向 REST 系統中，我們可以基於 URI 維護一個<strong>回應快取</strong>：</p><pre class="prism language-javascript">
<span class="token keyword">var</span> _cache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
rest<span class="token punctuation">.</span><span class="token keyword">get</span> <span class="token operator">=</span> uri <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>_cache<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>uri<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    _cache<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span>uri<span class="token punctuation">,</span> <span class="token function">fetch</span><span class="token punctuation">(</span>uri<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> _cache<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span>uri<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></pre><p>回應快取也可以應用到 GraphQL 上。基本的方法會用與 REST 版本類似地方式運作。query 的 text 本身可以用來作為快取的鍵：</p><pre class="prism language-javascript">
<span class="token keyword">var</span> _cache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
graphql<span class="token punctuation">.</span><span class="token keyword">get</span> <span class="token operator">=</span> queryText <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>_cache<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>queryText<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    _cache<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span>queryText<span class="token punctuation">,</span> <span class="token function">fetchGraphQL</span><span class="token punctuation">(</span>queryText<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> _cache<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span>queryText<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></pre><p>現在，請求先前快取過的資料可以馬上回應而不需要建立網路請求。這是一個提升應用程式察覺得到的效能的實用方法。不過，這個快取方法可能會導致資料一致性問題。</p><h2><a class="anchor" name=""></a>快取一致性 <a class="hash-link" href="#">#</a></h2><p>使用 GraphQL 數個 queries 的結果會重疊非常常見。不過，從上面章節而來的回應快取並沒有考慮到這種重疊 — 它基於不同的 queries 來做快取。舉例來說，如果我們發出一個 query 去抓取 stories：</p><pre class="prism language-javascript">
query <span class="token punctuation">{</span> stories <span class="token punctuation">{</span> id<span class="token punctuation">,</span> text<span class="token punctuation">,</span> likeCount <span class="token punctuation">}</span> <span class="token punctuation">}</span></pre><p>並接著再之後重新抓取其中一個 story，whose <code>likeCount</code> has since been incremented：</p><pre class="prism language-javascript">
query <span class="token punctuation">{</span> <span class="token function">story</span><span class="token punctuation">(</span>id<span class="token punctuation">:</span> <span class="token string">&quot;123&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> id<span class="token punctuation">,</span> text<span class="token punctuation">,</span> likeCount <span class="token punctuation">}</span> <span class="token punctuation">}</span></pre><p>我們現在將會看到不同的 <code>likeCount</code>，取決於這個 story 是如何被存取的。使用第一個 query 的 view 將會看到一個過期的 count，而使用第二個 query 的 view 將會看到已更新的 count。</p><h3><a class="anchor" name="graph"></a>快取一個 Graph <a class="hash-link" href="#graph">#</a></h3><p>快取 GraphQL 的解法是 normalize the hierarchical 回應 into a flat collection of <strong>records</strong>。Relay 實作這種快取為從 IDs 映射到 records 的 map。Each record is a map from field names to field values。Records 也可以連結到其他 records (允許它描述一個循環 graph)，and these links are stored as a special value type that references back into the top-level map。用這個方法，無論是如何被抓取的，每一個伺服器 record 都只會被儲存<em>一次</em>。</p><p>這是一個範例 query，它抓取一個 story 的 text 和它的 author 的 name：</p><pre class="prism language-javascript">
query <span class="token punctuation">{</span>
  <span class="token function">story</span><span class="token punctuation">(</span>id<span class="token punctuation">:</span> <span class="token string">&quot;1&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    text<span class="token punctuation">,</span>
    author <span class="token punctuation">{</span>
      name
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></pre><p>而這是一個可能的回應：</p><pre class="prism language-javascript">
query<span class="token punctuation">:</span> <span class="token punctuation">{</span>
  story<span class="token punctuation">:</span> <span class="token punctuation">{</span>
     text<span class="token punctuation">:</span> <span class="token string">&quot;Relay is open-source!&quot;</span><span class="token punctuation">,</span>
     author<span class="token punctuation">:</span> <span class="token punctuation">{</span>
       name<span class="token punctuation">:</span> <span class="token string">&quot;Jan&quot;</span>
     <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></pre><p>雖然回應是階層式的，we&#x27;ll 快取 it by flattening 所有的 records。Here is an example of how Relay would 快取 this query response：</p><pre class="prism language-javascript">
Map <span class="token punctuation">{</span>
  <span spellcheck="true" class="token comment">// `story(id: &quot;1&quot;)`</span>
  <span class="token number">1</span><span class="token punctuation">:</span> Map <span class="token punctuation">{</span>
    text<span class="token punctuation">:</span> <span class="token string">&#x27;Relay is open-source!&#x27;</span><span class="token punctuation">,</span>
    author<span class="token punctuation">:</span> <span class="token function">Link</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span spellcheck="true" class="token comment">// `story.author`</span>
  <span class="token number">2</span><span class="token punctuation">:</span> Map <span class="token punctuation">{</span>
    name<span class="token punctuation">:</span> <span class="token string">&#x27;Jan&#x27;</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></pre><p>這只是一個簡單的範例：現實中快取必須處理一對多關聯和 pagination (還有許多其他東西)。</p><h3><a class="anchor" name=""></a>使用快取 <a class="hash-link" href="#">#</a></h3><p>所以我們要如何使用這種快取？Let&#x27;s look at two operations：當收到回應時寫入到快取，and 從快取讀取 to determine if a query can be fulfilled locally (the equivalent to <code>_cache.has(key)</code> above, but for a graph)。</p><h3><a class="anchor" name="populating"></a>Populating 快取 <a class="hash-link" href="#populating">#</a></h3><p>Populating the cache involves walking a hierarchical GraphQL response and creating or updating normalized cache records。At first it may seem that the response alone is sufficient to process the response, but in fact this is only true for very simple queries。Consider <code>user(id: &quot;456&quot;) { photo(size: 32) { uri } }</code> — how should we store <code>photo</code>？Using <code>photo</code> as the field name in the cache won&#x27;t work because a different query might fetch the same field but with different argument values (e.g. <code>photo(size: 64) {...}</code>)。A similar issue occurs with pagination。If we fetch the 11th to 20th stories with <code>stories(first: 10, offset: 10)</code>, these new results should be <em>appended</em> to the existing list。</p><p>Therefore, a normalized response cache for GraphQL requires processing payloads and queries in parallel。For example, the <code>photo</code> field from above might be cached with a generated field name such as <code>photo_size(32)</code> in order to uniquely identify the field and its argument values。</p><h3><a class="anchor" name=""></a>從快取讀取 <a class="hash-link" href="#">#</a></h3><p>To read 從快取 we can walk a query and resolve each field。但是等等：that sounds <em>exactly</em> like what a GraphQL server does when it processes a query。And it is！Reading from the cache is a special case of an executor where a) there&#x27;s no need for user-defined field functions because all results come from a fixed data structure and b) results are always synchronous — we either have the data cached or we don&#x27;t。</p><p>Relay 實作了 several variations of <strong>query traversal</strong>：operations that walk a query alongside some other data such as the cache or a response payload。For example, when a query is fetched Relay performs a &quot;diff&quot; traversal to determine what fields are missing (much like React diffs virtual DOM trees)。 This can reduce the amount of data fetched in many common cases and even allow Relay to avoid network requests at all when queries are fully cached。</p><h3><a class="anchor" name=""></a>快取更新 <a class="hash-link" href="#">#</a></h3><p>Note that this normalized 快取結構 allows overlapping results to be cached without duplication。Each record is stored once regardless of how it is fetched。Let&#x27;s return to the earlier example of inconsistent data and see how this cache helps in that scenario。</p><p>第一個 query was for a list of stories：</p><pre class="prism language-javascript">
query <span class="token punctuation">{</span> stories <span class="token punctuation">{</span> id<span class="token punctuation">,</span> text<span class="token punctuation">,</span> likeCount <span class="token punctuation">}</span> <span class="token punctuation">}</span></pre><p>With a normalized response cache, a record would be created for each story in the list. The <code>stories</code> field would store links to each of these records.</p><p>第二個 query refetched the information for one of those stories：</p><pre class="prism language-javascript">
query <span class="token punctuation">{</span> <span class="token function">story</span><span class="token punctuation">(</span>id<span class="token punctuation">:</span> <span class="token string">&quot;123&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> id<span class="token punctuation">,</span> text<span class="token punctuation">,</span> likeCount <span class="token punctuation">}</span> <span class="token punctuation">}</span></pre><p>When this response is normalized, Relay can detect that this result overlaps with existing data based on its <code>id</code>. Rather than create a new record, Relay will update the existing <code>123</code> record. The new <code>likeCount</code> is therefore available to <em>both</em> queries, as well as any other query that might reference this story.</p><h2><a class="anchor" name="data-view"></a>Data/View 一致性 <a class="hash-link" href="#data-view">#</a></h2><p>A normalized cache ensures that the <em>cache</em> is consistent。But what about our views？Ideally, our React views would always reflect the current information from the cache。</p><p>Consider rendering the text and comments of a story along with the corresponding author names and photos。Here&#x27;s the GraphQL query：</p><pre class="prism language-javascript">
query <span class="token punctuation">{</span>
  <span class="token function">node</span><span class="token punctuation">(</span>id<span class="token punctuation">:</span> <span class="token string">&quot;1&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    text<span class="token punctuation">,</span>
    author <span class="token punctuation">{</span> name<span class="token punctuation">,</span> photo <span class="token punctuation">}</span><span class="token punctuation">,</span>
    comments <span class="token punctuation">{</span>
      text<span class="token punctuation">,</span>
      author <span class="token punctuation">{</span> name<span class="token punctuation">,</span> photo <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></pre><p>After initially fetching this story our cache might be as follows。Note that the story and comment both link to the same record as <code>author</code>：</p><pre class="prism language-javascript">
<span spellcheck="true" class="token comment">// Note：This is pseudo-code for `Map` initialization to make the structure</span>
<span spellcheck="true" class="token comment">// more obvious。</span>
Map <span class="token punctuation">{</span>
  <span spellcheck="true" class="token comment">// `story(id: &quot;1&quot;)`</span>
  <span class="token number">1</span><span class="token punctuation">:</span> Map <span class="token punctuation">{</span>
    author<span class="token punctuation">:</span> <span class="token function">Link</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    comments<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token function">Link</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span spellcheck="true" class="token comment">// `story.author`</span>
  <span class="token number">2</span><span class="token punctuation">:</span> Map <span class="token punctuation">{</span>
    name<span class="token punctuation">:</span> <span class="token string">&#x27;Yuzhi&#x27;</span><span class="token punctuation">,</span>
    photo<span class="token punctuation">:</span> <span class="token string">&#x27;http://.../photo1.jpg&#x27;</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span spellcheck="true" class="token comment">// `story.comments[0]`</span>
  <span class="token number">3</span><span class="token punctuation">:</span> Map <span class="token punctuation">{</span>
    author<span class="token punctuation">:</span> <span class="token function">Link</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span></pre><p>The author of this story also commented on it — quite common。Now imagine that some other view fetches new information about the author, and her profile photo has changed to a new URI。Here&#x27;s the <em>only</em> part of our cached data that changes：</p><pre class="prism language-javascript">
Map <span class="token punctuation">{</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token number">2</span><span class="token punctuation">:</span> Map <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    photo<span class="token punctuation">:</span> <span class="token string">&#x27;http://.../photo2.jpg&#x27;</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span></pre><p>The value of the <code>photo</code> field has changed; and therefore the record <code>2</code> has also changed。And that&#x27;s it。Nothing else in the <em>cache</em> is affected。But clearly our <em>view</em> needs to reflect the update：both instances of the author in the UI (as story author and comment author) need to show the new photo。</p><p>A standard response is to「just use immutable data structures」— but let&#x27;s see what would happen if we did：</p><pre class="prism language-javascript">
ImmutableMap <span class="token punctuation">{</span>
  <span class="token number">1</span><span class="token punctuation">:</span> ImmutableMap <span class="token punctuation">{</span><span spellcheck="true" class="token comment">/* same as before */</span><span class="token punctuation">}</span>
  <span class="token number">2</span><span class="token punctuation">:</span> ImmutableMap <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span spellcheck="true" class="token comment">// other fields unchanged</span>
    photo<span class="token punctuation">:</span> <span class="token string">&#x27;http://.../photo2.jpg&#x27;</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token number">3</span><span class="token punctuation">:</span> ImmutableMap <span class="token punctuation">{</span><span spellcheck="true" class="token comment">/* same as before */</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span></pre><p>If we replace <code>2</code> with a new immutable record, we&#x27;ll also get a new immutable instance of the cache object. However, records <code>1</code> and <code>3</code> are untouched. Because the data is normalized, we can&#x27;t tell that <code>story</code>&#x27;s contents have changed just by looking at the <code>story</code> record alone.</p><h3><a class="anchor" name="achieving-view-consistency"></a>Achieving View Consistency <a class="hash-link" href="#achieving-view-consistency">#</a></h3><p>There are a variety of solutions for keeping views up to date with a flattened cache. The approach that Relay takes is to maintain a mapping from each UI view to the set of IDs it references. In this case, the story view would subscribe to updates on the story (<code>1</code>), the author (<code>2</code>), and the comments (<code>3</code> and any others). When writing data into the cache, Relay tracks which IDs are affected and notifies <em>only</em> the views that are subscribed to those IDs. The affected views re-render, and unaffected views opt-out of re-rendering for better performance (Relay provides a safe but effective default <code>shouldComponentUpdate</code>). Without this strategy, every view would re-render for even the tiniest change.</p><p>Note that this solution will also work for <em>writes</em>: any update to the cache will notify the affected views, and writes are just another thing that updates the cache.</p><h2><a class="anchor" name="mutations"></a>Mutations <a class="hash-link" href="#mutations">#</a></h2><p>So far we&#x27;ve looked at the process of querying data and keeping views up to date, but we haven&#x27;t looked at writes. In GraphQL, writes are called <strong>mutations</strong>. We can think of them as queries with side effects. Here&#x27;s an example of calling a mutation that might mark a given story as being liked by the current user:</p><pre class="prism language-javascript">
<span spellcheck="true" class="token comment">// Give a human-readable name and define the types of the inputs,</span>
<span spellcheck="true" class="token comment">// in this case the id of the story to mark as liked.</span>
mutation <span class="token function">StoryLike</span><span class="token punctuation">(</span>$storyID<span class="token punctuation">:</span> String<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span spellcheck="true" class="token comment">// Call the mutation field and trigger its side effects</span>
   <span class="token function">storyLike</span><span class="token punctuation">(</span>storyID<span class="token punctuation">:</span> $storyID<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span spellcheck="true" class="token comment">// Define fields to re-fetch after the mutation completes</span>
     likeCount
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span></pre><p>Notice that we&#x27;re querying for data that <em>may</em> have changed as a result of the mutation. An obvious question is: why can&#x27;t the server just tell us what changed? The answer is: it&#x27;s complicated. GraphQL abstracts over <em>any</em> data storage layer (or an aggregation of multiple sources), and works with any programming language. Furthermore, the goal of GraphQL is to provide data in a form that is useful to product developers building a view.</p><p>We&#x27;ve found that it&#x27;s common for the GraphQL schema to differ slightly or even substantially from the form in which data is stored on disk. Put simply: there isn&#x27;t always a 1:1 correspondence between data changes in your underlying <em>data storage</em> (disk) and data changes in your <em>product-visible schema</em> (GraphQL). The perfect example of this is privacy: returning a user-facing field such as <code>age</code> might require accessing numerous records in our data-storage layer to determine if the active user is even allowed to <em>see</em> that <code>age</code> (Are we friends? Is my age shared? Did I block you? etc.).</p><p>Given these real-world constraints, the approach in GraphQL is for clients to query for things that may change after a mutation. But what exactly do we put in that query? During the development of Relay we explored several ideas — let&#x27;s look at them briefly in order to understand why Relay uses the approach that it does:</p><ul><li><p>Option 1: Re-fetch everything that the app has ever queried. Even though only a small subset of this data will actually change, we&#x27;ll still have to wait for the server to execute the <em>entire</em> query, wait to download the results, and wait to process them again. This is very inefficient.</p></li><li><p>Option 2: Re-fetch only the queries required by actively rendered views. This is a slight improvement over option 1. However, cached data that <em>isn&#x27;t</em> currently being viewed won&#x27;t be updated. Unless this data is somehow marked as stale or evicted from the cache subsequent queries will read outdated information.</p></li><li><p>Option 3: Re-fetch a fixed list of fields that <em>may</em> change after the mutation. We&#x27;ll call this list a <strong>fat query</strong>. We found this to also be inefficient because typical applications only render a subset of the fat query, but this approach would require fetching all of those fields.</p></li><li><p>Option 4 (Relay): Re-fetch the intersection of what may change (the fat query) and the data in the cache. In addition to the cache of data Relay also remembers the queries used to fetch each item. These are called <strong>tracked queries</strong>. By intersecting the tracked and fat queries, Relay can query exactly the set of information the application needs to update and nothing more.</p></li></ul><h2><a class="anchor" name="apis"></a>資料抓取 APIs <a class="hash-link" href="#apis">#</a></h2><p>到目前為止，we looked at the lower-level aspects of data-fetching and saw how various familiar concepts translate to GraphQL. Next, let&#x27;s step back and look at some higher-level concerns that product developers often face around data-fetching:</p><ul><li>Fetching all the data for a view hierarchy.</li><li>Managing asynchronous state transitions and coordinating concurrent requests.</li><li>Managing errors.</li><li>Retrying failed requests.</li><li>Updating the local cache after receiving query/mutation responses.</li><li>Queuing mutations to avoid race conditions.</li><li>Optimistically updating the UI while waiting for the server to respond to mutations.</li></ul><p>We&#x27;ve found that typical approaches to 資料抓取 — with imperative APIs — force developers to deal with too much of this non-essential complexity. For example, consider <em>optimistic UI updates</em>. This is a way of giving the user feedback while waiting for a server response. The logic of <em>what</em> to do can be quite clear: when the user clicks &quot;like&quot;, mark the story as being liked and send the request to the server. But the implementation is often much more complex. Imperative approaches require us to implement all of those steps: reach into the UI and toggle the button, initiate a network request, retry it if necessary, show an error if it fails (and untoggle the button), etc. The same goes for 資料抓取：specifying <em>what</em> data we need often dictates <em>how</em> and <em>when</em> it is fetched. Next, we&#x27;ll explore our approach to solving these concerns with <strong>Relay</strong>.</p></div><div class="docs-prevnext"><a class="docs-next" href="thinking-in-relay.html#content">Next →</a></div></div></section><footer class="wrap"><div class="right">©2015 Facebook Inc.</div></footer></div><div id="fb-root"></div><script>
            !function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+"://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");
            (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
              ga('create', 'UA-71174216-1', 'auto');
              ga('send', 'pageview');
          </script></body></html>